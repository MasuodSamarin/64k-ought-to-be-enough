#!/usr/bin/env python3
# ----------------------------------------------------------------------------
# Generaters pre-calculated coordinates for elipses
# ----------------------------------------------------------------------------
"""
Tool to generate elipse paths.
"""
import math
import argparse


__docformat__ = 'restructuredtext'


class Elipse:
    def __init__(self, output_fd):
        self._output_fd = output_fd

    def calc(self, x, y, a):
        new_x = x * math.cos(a) - y * math.sin(a)
        new_y = x * math.sin(a) + y * math.cos(a)
        return (new_x, new_y)

    def run(self, radius_min, radius_max, values_per_quadrant):
        points = {}
        # calculate for when points are based between radius_min and radius_max
        for px in range(radius_min, radius_max):
            tmp_list = []
            # only first quadrant (90 degrees only)
            degree_increment = 90 / values_per_quadrant
            for a in reversed(range(0, values_per_quadrant)):
                rad = math.radians(a * degree_increment)
                x, y = self.calc(px, 0, rad)
                # using top-left as coordinate 0,0.
                # negating y allow us to use a top-down coordinate for y
                y = -y
                tmp_list.append((round(x), round(y)))
            points[px] = tmp_list
        self.output(points)

    def output_coords_for_radius(self, points):
        first = True
        count = 0
        for x, y in points:
            if x < 0:
                x = (x+256) % 256
            if y < 0:
                y = (y+256) % 256

            if first:
                self._output_fd.write('        dw 0x%04x' % (y * 256 + x))
                first = False
            else:
                self._output_fd.write(', 0x%04x' % (y * 256 + x))

            count += 1
            # no more than 16 elements per line
            if count >= 8:
                first = True
                count = 0
                self._output_fd.write('\n')
        self._output_fd.write('\n')

    def output(self, dict_of_points):
        self._output_fd.write(';=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-;\n')
        self._output_fd.write('; Autogenerated with generate_elipse.py\n')
        self._output_fd.write('; DO NOT MODIFY\n')
        self._output_fd.write(';=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-;\n')
        entries = []
        for radius in dict_of_points:
            name = 'elipse_coords_for_radius_%d' % radius
            entries.append(name)
            self._output_fd.write('%s:\n' % name)
            self.output_coords_for_radius(dict_of_points[radius])

        # dump entries table
        self._output_fd.write(';=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-;\n')
        self._output_fd.write('; Entries\n')
        self._output_fd.write(';=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-;\n')
        self._output_fd.write('elipse_table:\n')
        for entry in entries:
            self._output_fd.write('        dw %s\n' % entry)


def parse_args():
    """Parse the arguments."""
    parser = argparse.ArgumentParser(
        description='Generates circle/elipse table to be used to rotate vectors', epilog="""Example:

$ %(prog)s -o table.asm
""")
    parser.add_argument('-o', '--output-file', metavar='<filename>',
            help='output file. Default: stdout', required=True)
    parser.add_argument('-v', '--values-per-quadrant', type=int,
            metavar='<values_per_quadrant>',
            help='Total values to generate per quadrant. Default: 90',
            default=90)

    args = parser.parse_args()
    return args


def main():
    args = parse_args()
    with open(args.output_file, 'w+') as fd:
        # radius: between 1 and 50 (50 not included)
        Elipse(fd).run(0, 50, args.values_per_quadrant)


if __name__ == "__main__":
    main()
