#!/usr/bin/env python3
# ----------------------------------------------------------------------------
# Generaters pre-calculated coordinates for elipses
# ----------------------------------------------------------------------------
"""
Tool to generate elipse paths.
"""
import math
import argparse


__docformat__ = 'restructuredtext'


class Elipse:
    def __init__(self, output_fd):
        self._output_fd = output_fd

    def calc(self, x, y, a):
        new_x = x * math.cos(a) - y * math.sin(a)
        new_y = x * math.sin(a) + y * math.cos(a)
        return (new_x, new_y)

    def run(self, min_y, max_y, values_per_octant):
        points = {}
        # calculate for when points are based between min_y and max_y
        for px in range(min_y, max_y):
            tmp_list = []
            # only first octant (90 degrees only)
            degree_increment = 90 / values_per_octant
            for a in reversed(range(0, values_per_octant)):
                rad = math.radians(a * degree_increment)
                x, y = self.calc(px, 0, rad)
                tmp_list.append((int(x), int(y)))
            points[px] = tmp_list
        self.output(points)

    def output_one_coord(self, points, coord_idx):
        first = True
        count = 0
        for p in points:
            if first:
                self._output_fd.write('        db %d' % p[coord_idx])
                first = False
            else:
                self._output_fd.write(', %d' % p[coord_idx])
            count += 1
            # no more than 16 elements per line
            if count >= 16:
                first = True
                count = 0
                self._output_fd.write('\n')
        self._output_fd.write('\n')

    def output(self, points):
        entries_x = []
        entries_y = []
        self._output_fd.write(';=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-;\n')
        self._output_fd.write('; Autogenerated with generate_elipse.py\n')
        self._output_fd.write('; DO NOT MODIFY\n')
        self._output_fd.write(';=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-;\n')
        for k in points:
            name = 'elipse_%d_x' % k
            entries_x.append(name)
            self._output_fd.write('%s:\n' % name)
            self.output_one_coord(points[k], 0)

            name = 'elipse_%d_y' % k
            entries_y.append(name)
            self._output_fd.write('%s:\n' % name)
            self.output_one_coord(points[k], 1)

        # dump entries table
        self._output_fd.write(';=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-;\n')
        self._output_fd.write('; Entries\n')
        self._output_fd.write(';=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-;\n')
        self._output_fd.write('elipse_table_x:\n')
        for entry in entries_x:
            self._output_fd.write('        dw %s\n' % entry)
        self._output_fd.write('elipse_table_y:\n')
        for entry in entries_y:
            self._output_fd.write('        dw %s\n' % entry)


def parse_args():
    """Parse the arguments."""
    parser = argparse.ArgumentParser(
        description='Generates circle/elipse table to be used to rotate vectors', epilog="""Example:

$ %(prog)s -o table.asm
""")
    parser.add_argument('-o', '--output-file', metavar='<filename>',
            help='output file. Default: stdout', required=True)
    parser.add_argument('-v', '--values-per-octant', type=int,
            metavar='<values_per_octant>',
            help='Total values to generate per octant. Default: 90',
            default=90)

    args = parser.parse_args()
    return args


def main():
    args = parse_args()
    with open(args.output_file, 'w+') as fd:
        Elipse(fd).run(1, 50, args.values_per_octant)


if __name__ == "__main__":
    main()
